use std::collections::*;
use std::fmt::{self, Display, Formatter};
use std::io::Write;

use maulingmonkey_windows_sdk_scanner::*;
use mmrbi::*;



fn headers() -> impl Iterator<Item = &'static str> {
    include_str!("../thindx/doc/headers.txt").lines().map(|l| l.split_once('#').map_or(l, |l| l.0).trim()).filter(|l| !l.is_empty())
}

pub fn update() {
    let cpp2rust = &*CPP2RUST;

    use maulingmonkey_windows_sdk_scanner::*;
    let sdk = sdk::WindowsKit::find_latest().unwrap();
    let mut cpp = RootBuilder::new();
    for file in headers() { cpp.add_from_cpp_path(sdk.include.join(file)).unwrap(); }
    let cpp : Root = cpp.finish();
    let headers = headers().map(|h| Header::new(h, &cpp)).collect::<Vec<_>>();

    mmrbi::fs::write_if_modified_with("thindx/src/_headers.rs", |rs|{
        writeln!(rs, "// This file is autogenerated by _xtask.rs")?;
        writeln!(rs)?;
        writeln!(rs, "#![warn(rustdoc::broken_intra_doc_links)]")?;
        writeln!(rs)?;
        writeln!(rs, "//! Rust ⮀ C++ coverage information based on Windows SDK {}", sdk.sdk_version)?;
        writeln!(rs, "//!")?;
        writeln!(rs, "//! ⚠️ Scanned C++ definitions are not yet complete.")?;
        writeln!(rs, "//! Based on [MaulingMonkey/windows-sdk-scanner](https://github.com/MaulingMonkey/windows-sdk-scanner).")?;
        writeln!(rs, "//!")?;



        writeln!(rs, "//! # Headers")?;
        writeln!(rs, "//!")?;
        writeln!(rs, "//! | C++ Header | Interfaces | Structs | Enums | Functions |")?;
        writeln!(rs, "//! | ---------- | ---------- | ------- | ----- | --------- |")?;
        for header in headers.iter() {
            write!(rs, "//! |")?;
            write!(rs, " [{name}](#{id}h) |", name = header.name_h, id = header.name)?;
            for (mapped, total) in [
                (header.interfaces .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.interfaces   .len()),
                (header.structs    .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.structs      .len()),
                (header.enums      .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.enums        .len()),
                (header.functions  .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.functions    .len()),
                // (header.classes    .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.classes      .len()),
                // (header.unions     .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.unions       .len()),
            ].into_iter() {
                write!(rs, " {} |", ProgressBadge(mapped, total))?;
            }
            writeln!(rs)?;
        }
        writeln!(rs, "//!")?;



        for header in headers.iter() {
            let interfaces  = header.interfaces .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            let structs     = header.structs    .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            let enums       = header.enums      .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            let functions   = header.functions  .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            // let classes     = header.classes    .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            // let unions      = header.unions     .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));

            writeln!(rs, "//!")?;
            writeln!(rs, "//! <br>")?;
            writeln!(rs, "//!")?;
            writeln!(rs, "//! # {}", header.name_h)?;
            writeln!(rs, "//!")?;

            for (idx, (cpp, rust)) in interfaces.enumerate() {
                if idx == 0 {
                    writeln!(rs, "//! ### C++ Interfaces → Rust Types")?;
                    writeln!(rs, "//!")?;
                }
                write!(rs, "//! {}", CppLink(&cpp.id))?;
                for (idx, rust) in rust.into_iter().flat_map(|p| p.iter()).enumerate() { write!(rs, "{}[`{}`]", if idx == 0 { "&nbsp;→ " } else { ", " }, rust)?; }
                if rust.is_none() { write!(rs, " →&nbsp;❌")?; }
                writeln!(rs, " <br>")?;
                for method in cpp.methods() {
                    let cpp     = format!("{}::{}", method.ty, method.f.id);
                    let rust    = cpp2rust.get(&*cpp);
                    write!(rs, "//! * {}", CppLink(&cpp))?;
                    for (idx, rust) in rust.into_iter().flat_map(|p| p.iter()).enumerate() { write!(rs, "{}[`{}`]", if idx == 0 { "&nbsp;→ " } else { ", " }, rust)?; }
                    if rust.is_none() { write!(rs, " →&nbsp;❌")?; }
                    writeln!(rs, " <br>")?;
                }
                writeln!(rs, "//!")?;
            }

            for (idx, (cpp, rust)) in structs.enumerate() {
                if idx == 0 {
                    writeln!(rs, "//! ### C++ Structs -> Rust Structs")?;
                    writeln!(rs, "//!")?;
                }
                write!(rs, "//! {}", CppLink(&cpp.id))?;
                for (idx, rust) in rust.into_iter().flat_map(|p| p.iter()).enumerate() { write!(rs, "{}[`{}`]", if idx == 0 { "&nbsp;→ " } else { ", " }, rust)?; }
                if rust.is_none() { write!(rs, " →&nbsp;❌")?; }
                writeln!(rs, " <br>")?;
            }

            for (idx, (cpp, rust)) in enums.enumerate() {
                if idx == 0 {
                    writeln!(rs, "//! ### C++ Enums → Rust Structs")?;
                    writeln!(rs, "//!")?;
                }
                write!(rs, "//! {}", CppLink(&cpp.id))?;
                for (idx, rust) in rust.into_iter().flat_map(|p| p.iter()).enumerate() { write!(rs, "{}[`{}`]", if idx == 0 { "&nbsp;→ " } else { ", " }, rust)?; }
                if rust.is_none() { write!(rs, " →&nbsp;❌")?; }
                writeln!(rs, " <br>")?;
                // TODO: constants
            }

            for (idx, (cpp, rust)) in functions.enumerate() {
                if idx == 0 {
                    writeln!(rs, "//! ### C++ Functions → Rust Fns")?;
                    writeln!(rs, "//!")?;
                }
                write!(rs, "//! {}", CppLink(&cpp.id))?;
                for (idx, rust) in rust.into_iter().flat_map(|p| p.iter()).enumerate() { write!(rs, "{}[`{}`]", if idx == 0 { "&nbsp;→ " } else { ", " }, rust)?; }
                if rust.is_none() { write!(rs, " →&nbsp;❌")?; }
                writeln!(rs, " <br>")?;
            }

            // classes, unions
        }



        writeln!(rs, "use crate::*;")?;
        Ok(())
    }).unwrap_or_else(|err| fatal!("unable to create `thindx/src/_headers.rs`: {}", err));
}

struct Header<'cpp> {
    name_h:     &'static str,
    name:       &'static str,
    interfaces: Vec<&'cpp cpp::Interface>,
    structs:    Vec<&'cpp cpp::Struct>,
    enums:      Vec<&'cpp cpp::Enum>,
    functions:  Vec<&'cpp cpp::Function>,
    // classes:    Vec<&'cpp cpp::Class>,
    // unions:     Vec<&'cpp cpp::Union>,
}
impl<'cpp> Header<'cpp> {
    fn new(rel_path: &'static str, cpp: &'cpp Root) -> Self {
        let ignore = &*CPP2IGNORE;
        let name_h = rel_path.rfind('\\').map_or(rel_path, |s| &rel_path[s+1..]);
        let name   = name_h.strip_suffix(".h").unwrap_or(name_h);
        Self {
            name_h, name,
            interfaces: cpp.interfaces  .values_by_key().filter(move |t| !ignore.contains(t.id.as_str()) && t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            structs:    cpp.structs     .values_by_key().filter(move |t| !ignore.contains(t.id.as_str()) && t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            enums:      cpp.enums       .values_by_key().filter(move |t| !ignore.contains(t.id.as_str()) && t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            functions:  cpp.functions   .values_by_key().filter(move |t| !ignore.contains(t.id.as_str()) && t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            // classes:    cpp.classes     .values_by_key().filter(move |t| !ignore.contains(t.id.as_str()) && t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            // unions:     cpp.unions      .values_by_key().filter(move |t| !ignore.contains(t.id.as_str()) && t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
        }
    }
}

lazy_static::lazy_static! {
    static ref CPP2IGNORE   : BTreeSet<&'static str>                    = set_file("thindx/doc/cpp2ignore.txt", include_str!("../thindx/doc/cpp2ignore.txt"));
    static ref CPP2RUST     : BTreeMap<&'static str, Vec<&'static str>> = map_file("thindx/doc/cpp2rust.txt", include_str!("../thindx/doc/cpp2rust.txt"));
    static ref CPP2URL      : BTreeMap<&'static str, Vec<&'static str>> = map_file("thindx/doc/cpp2url.txt", include_str!("../thindx/doc/cpp2url.txt"));
}

fn set_file<'s>(_path: &str, text: &'s str) -> BTreeSet<&'s str> {
    let mut r = BTreeSet::<&str>::new();
    for line in text.lines() {
        let line = line.split_once('#').map_or(line, |s| s.0).trim();
        if line.is_empty() { continue }

        r.insert(line.trim());
    }
    r
}

fn map_file<'s>(path: &str, text: &'s str) -> BTreeMap<&'s str, Vec<&'s str>> {
    let mut r = BTreeMap::<&'s str, Vec<&'s str>>::new();
    for (line_idx, line) in text.lines().enumerate() {
        let line_no = line_idx + 1;
        let line = line.split_once('#').map_or(line, |s| s.0).trim();
        if line.is_empty() { continue }

        if let Some((k, v)) = line.split_once('=') {
            r.entry(k.trim()).or_default().push(v.trim());
        } else {
            error!(at: path, line: line_no, "expected `key = value` pair");
        }
    }
    r
}



/// Markdownify a coverage bage.
///
/// *   `❌ 0 of 24`
/// *   `⚠️ 23 of 24`
/// *   `✔️ 24 of 24`
struct ProgressBadge(usize, usize);

impl Display for ProgressBadge {
    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
        match *self {
            ProgressBadge(0, 0)             => write!(fmt, " "),
            ProgressBadge(0, n)             => write!(fmt, "❌ 0 of {}", n),
            ProgressBadge(i, n) if i == n   => write!(fmt, "✔️ {} of {}", i, n),
            ProgressBadge(i, n)             => write!(fmt, "⚠️ {} of {}", i, n),
        }
    }
}



/// Markdownify a C++ identifier into a (possibly hyperlinked) code block
struct CppLink<'s>(&'s str);

impl Display for CppLink<'_> {
    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
        match CPP2URL.get(self.0) {
            Some(url)   => write!(fmt, "[`{}`]({})", self.0, url[0]),
            None        => write!(fmt, "`{}`", self.0),
        }
    }
}
