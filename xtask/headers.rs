use std::collections::*;
use std::fmt::{self, Display, Formatter};
use std::io::Write;

use maulingmonkey_windows_sdk_scanner::*;
use mmrbi::*;

const HEADERS : &'static [&'static str] = &[
    r"um\unknwn.h", //r"um\unknwnbase.h",
    r"um\d3d11shader.h",
    r"um\d3dcommon.h",
    r"um\d3dcompiler.h",
    r"um\d3d11shadertracing.h",
];


pub fn update() {
    let cpp2rust = &*CPP2RUST;

    use maulingmonkey_windows_sdk_scanner::*;
    let sdk = sdk::WindowsKit::find_latest().unwrap();
    let mut cpp = RootBuilder::new();
    for file in HEADERS.iter().copied() { cpp.add_from_cpp_path(sdk.include.join(file)).unwrap(); }
    let cpp : Root = cpp.finish();
    let headers = HEADERS.iter().copied().map(|h| Header::new(h, &cpp)).collect::<Vec<_>>();

    mmrbi::fs::write_if_modified_with("thindx/src/_headers.rs", |rs|{
        writeln!(rs, "// This file is autogenerated by _xtask.rs")?;
        writeln!(rs)?;
        writeln!(rs, "#![warn(rustdoc::broken_intra_doc_links)]")?;
        writeln!(rs)?;
        writeln!(rs, "//! Rust ⮀ C++ coverage information based on Windows SDK {}", sdk.sdk_version)?;
        writeln!(rs, "//!")?;
        writeln!(rs, "//! ⚠️ Scanned C++ definitions are not yet complete.")?;
        writeln!(rs, "//! Based on [MaulingMonkey/windows-sdk-scanner](https://github.com/MaulingMonkey/windows-sdk-scanner).")?;
        writeln!(rs, "//!")?;
        writeln!(rs, "//! <style>#main {{ max-width: 1500px; }}</style>")?;
        writeln!(rs, "//!")?;



        writeln!(rs, "//! # Headers")?;
        writeln!(rs, "//!")?;
        writeln!(rs, "//! | C++ Header | Interfaces | Structs | Enums |")?;
        writeln!(rs, "//! | ---------- | ---------- | ------- | ----- |")?;
        for header in headers.iter() {
            write!(rs, "//! |")?;
            write!(rs, " [{name}](#{id}) |", name = header.name_h, id = header.name)?;
            for (mapped, total) in [
                (header.interfaces .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.interfaces   .len()),
                (header.structs    .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.structs      .len()),
                (header.enums      .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.enums        .len()),
                // (header.functions  .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.functions    .len()),
                // (header.classes    .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.classes      .len()),
                // (header.unions     .iter().filter(|t| cpp2rust.get(t.id.as_str()).is_some()).count(),   header.unions       .len()),
            ].into_iter() {
                write!(rs, " {} |", ProgressBadge(mapped, total))?;
            }
            writeln!(rs)?;
        }
        writeln!(rs, "//!")?;



        for header in headers.iter() {
            let interfaces  = header.interfaces .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            let structs     = header.structs    .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            let enums       = header.enums      .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            // let functions   = header.functions  .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            // let classes     = header.classes    .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));
            // let unions      = header.unions     .iter().map(|t| (t, cpp2rust.get(t.id.as_str())));

            writeln!(rs, "//! <h3 id=\"{id}\">{name}</h3>", name = header.name_h, id = header.name)?;
            writeln!(rs, "//!")?;

            for (idx, (cpp, rust)) in interfaces.enumerate() {
                if idx == 0 {
                    writeln!(rs, "//!")?;
                    writeln!(rs, "//! |  ?  | C++ Interface | Rust Type | Methods |")?;
                    writeln!(rs, "//! | --- | ------------- | --------- | ------- |")?;
                }
                write!(rs, "//! | {} | {} |", ok_if(rust.is_some()), CppLink(&cpp.id))?;
                for rust in rust.into_iter().flat_map(|p| p.iter()) { write!(rs, " [`{}`]<br>", rust)?; }
                write!(rs, " |")?;

                let mapped = cpp.methods().filter(|m| cpp2rust.contains_key(&format!("{}::{}", cpp.id, m.f.id))).count();
                let total = cpp.methods().count();
                write!(rs, " {} {} of {}", ok_if(mapped == total), mapped, total)?;
                writeln!(rs, " |")?;
            }

            for (idx, (cpp, rust)) in structs.enumerate() {
                if idx == 0 {
                    writeln!(rs, "//!")?;
                    writeln!(rs, "//! |  ?  | C++ Struct    | Rust Type |")?;
                    writeln!(rs, "//! | --- | ------------- | --------- |")?;
                }
                write!(rs, "//! | {} | {} |", ok_if(rust.is_some()), CppLink(&cpp.id))?;
                for rust in rust.into_iter().flat_map(|p| p.iter()) { write!(rs, " [`{}`]<br>", rust)?; }
                writeln!(rs, " |")?;
            }

            for (idx, (cpp, rust)) in enums.enumerate() {
                if idx == 0 {
                    writeln!(rs, "//!")?;
                    writeln!(rs, "//! |  ?  | C++ Enum      | Rust Type | Constants |")?;
                    writeln!(rs, "//! | --- | ------------- | --------- | --------- |")?;
                }
                write!(rs, "//! | {} | {} |", ok_if(rust.is_some()), CppLink(&cpp.id))?;
                for rust in rust.into_iter().flat_map(|p| p.iter()) { write!(rs, " [`{}`]<br>", rust)?; }
                write!(rs, " |")?;
                write!(rs, " ??? of ??? |")?;
                writeln!(rs)?;
            }

            // functions, classes, unions

            for (idx, icpp) in header.interfaces.iter().enumerate() {
                if idx == 0 {
                    writeln!(rs, "//!")?;
                    writeln!(rs, "//! |  ?  | C++ Method    | Rust Method |")?;
                    writeln!(rs, "//! | --- | ------------- | ----------- |")?;
                }
                for method in icpp.methods() {
                    let cpp     = format!("{}::{}", method.ty, method.f.id);
                    let rust    = cpp2rust.get(&cpp);
                    write!(rs, "//! | {} | {} |", ok_if(rust.is_some()), CppLink(&cpp))?;
                    for rust in rust.into_iter().flat_map(|p| p.iter()) { write!(rs, " [`{}`]<br>", rust)?; }
                    writeln!(rs, " |")?;
                }
            }
        }



        writeln!(rs, "use crate::*;")?;
        Ok(())
    }).unwrap_or_else(|err| fatal!("unable to create `thindx/src/_headers.rs`: {}", err));
}

struct Header<'cpp> {
    name_h:     &'static str,
    name:       &'static str,
    interfaces: Vec<&'cpp cpp::Interface>,
    structs:    Vec<&'cpp cpp::Struct>,
    enums:      Vec<&'cpp cpp::Enum>,
    // functions:  Vec<&'cpp cpp::Function>,
    // classes:    Vec<&'cpp cpp::Class>,
    // unions:     Vec<&'cpp cpp::Union>,
}
impl<'cpp> Header<'cpp> {
    fn new(rel_path: &'static str, cpp: &'cpp Root) -> Self {
        let name_h = rel_path.rfind('\\').map_or(rel_path, |s| &rel_path[s+1..]);
        let name   = name_h.strip_suffix(".h").unwrap_or(name_h);
        Self {
            name_h, name,
            interfaces: cpp.interfaces  .values_by_key().filter(move |t| t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            structs:    cpp.structs     .values_by_key().filter(move |t| t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            enums:      cpp.enums       .values_by_key().filter(move |t| t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            // functions:  cpp.functions   .values_by_key().filter(move |t| t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            // classes:    cpp.classes     .values_by_key().filter(move |t| t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
            // unions:     cpp.unions      .values_by_key().filter(move |t| t.defined_at.iter().any(move |at| at.path.ends_with(rel_path))).collect(),
        }
    }
}

lazy_static::lazy_static! {
    static ref CPP2RUST : BTreeMap<String, Vec<String>> = map_file("doc/cpp2rust.txt", include_str!("../doc/cpp2rust.txt"));
    static ref CPP2URL  : BTreeMap<String, Vec<String>> = map_file("doc/cpp2url.txt", include_str!("../doc/cpp2url.txt"));
}

fn map_file(path: &str, text: &str) -> BTreeMap<String, Vec<String>> {
    let mut r = BTreeMap::<String, Vec<String>>::new();
    for (line_idx, line) in text.lines().enumerate() {
        let line_no = line_idx + 1;
        let line = line.split_once('#').map_or(line, |s| s.0).trim();
        if line.is_empty() { continue }

        if let Some((k, v)) = line.split_once('=') {
            r.entry(k.trim().to_string()).or_default().push(v.trim().to_string());
        } else {
            error!(at: path, line: line_no, "expected `key = value` pair");
        }
    }
    r
}



/// Markdownify a coverage bage.
///
/// *   `❌ 0 of 24`
/// *   `⚠️ 23 of 24`
/// *   `✔️ 24 of 24`
struct ProgressBadge(usize, usize);

impl Display for ProgressBadge {
    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
        match *self {
            ProgressBadge(0, 0)             => write!(fmt, " "),
            ProgressBadge(0, n)             => write!(fmt, "❌ 0 of {}", n),
            ProgressBadge(i, n) if i == n   => write!(fmt, "✔️ {} of {}", i, n),
            ProgressBadge(i, n)             => write!(fmt, "⚠️ {} of {}", i, n),
        }
    }
}



/// Markdownify a C++ identifier into a (possibly hyperlinked) code block
struct CppLink<'s>(&'s str);

impl Display for CppLink<'_> {
    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
        match CPP2URL.get(self.0) {
            Some(url)   => write!(fmt, "[`{}`]({})", self.0, url[0]),
            None        => write!(fmt, "`{}`", self.0),
        }
    }
}



fn ok_if(ok: bool) -> &'static str { if ok { OK } else { ERR } }

const OK  : &'static str = "✔️";
const ERR : &'static str = "❌";
