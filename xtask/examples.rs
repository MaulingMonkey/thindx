use crate::*;
use crate::crlf::EolRewriter;

use mmrbi::*;

use std::io::Write;
use std::time::SystemTime;



pub fn update() {
    download_extract_assets();

    mmrbi::fs::write_if_modified_with("thindx/src/_examples.rs", |o|{
        let mut o = EolRewriter(o);

        writeln!(o, "// This file is autogenerated by _xtask.rs")?;
        writeln!(o)?;
        writeln!(o, "//! # Examples")?;
        writeln!(o, "use crate::*;")?;

        for e in mmrbi::fs::DirPathType::read_by_alphanumeric("thindx/examples").unwrap_or_else(|err| fatal!("unable to enumerate thindx/examples: {}", err)) {
            if !e.file_type.is_file() { continue }
            let name = e.path.file_name().unwrap_or_else(|| fatal!("expected file_name for {}", e.path.display()));
            let name = name.to_string_lossy();
            let name = match name.strip_suffix(".rs") { Some(n) => n, None => continue };

            let output = ExampleOutput::get(name, "debug");
            let mut src = output.src.lines().peekable();

            writeln!(o)?;

            let mut any = false;
            while src.peek().map_or(false, |l| l.starts_with("//!")) {
                writeln!(o, "///{}", src.next().unwrap()[3..].trim_end())?;
                any = true;
            }
            if !any {
                writeln!(o, "/// {}", name)?;
            }

            while src.peek().map_or(false, |l| l.trim().is_empty()) { let _ = src.next(); }

            if let Some(screenshot) = output.screenshot.as_ref() {
                writeln!(o, "///")?;
                writeln!(o, "/// <center>")?;
                writeln!(o, "/// <h4 id=\"screenshots\" class=\"section-header\"><a href=\"#screenshots\">Screenshots</a></h4>")?;
                let url = format!("data:image/png;base64,{}", base64::encode(screenshot));
                writeln!(o, "/// <img src=\"{}\">", url)?;
                writeln!(o, "/// </center>")?;
            }

            writeln!(o, "///")?;
            writeln!(o, "/// ### Source")?;
            writeln!(o, "/// ```no_run")?;
            for line in src {
                assert!(!line.contains("```"));
                writeln!(o, "/// {}", line.trim_end())?;
            }
            writeln!(o, "/// ```")?;

            if !output.console.is_empty() {
                writeln!(o, "///")?;
                writeln!(o, "/// ### Output")?;
                writeln!(o, "/// ```text")?;
                for line in output.console.lines() {
                    assert!(!line.contains("```"));
                    writeln!(o, "/// {}", line.trim_end())?;
                }
                writeln!(o, "/// ```")?;
            }
            writeln!(o, "///")?;
            writeln!(o, "/// ### To run this example yourself")?;
            writeln!(o, "/// ```cmd")?;
            writeln!(o, "/// git clone https://github.com/MaulingMonkey/thindx")?;
            writeln!(o, "/// cd thindx")?;
            writeln!(o, "/// cargo run --example {}", name)?;
            writeln!(o, "/// ```")?;
            writeln!(o, "pub const {} : () = ();", name.replace("-", "_"))?;
        }

        Ok(())
    }).unwrap_or_else(|err| fatal!("unable to create `thindx/src/_examples.rs`: {}", err));
}

pub fn download_extract_assets() {
    let url = "https://thoseawesomeguys.com/prompts/Xelu_Free_Controller&Key_Prompts.zip";

    let xelu_dir = Path::new("thindx/examples/assets/xelu");
    std::fs::create_dir_all(xelu_dir).unwrap_or_else(|err| fatal!("unable to create directory {}: {}", xelu_dir.display(), err));

    let xelu_zip = Path::new("thindx/examples/assets/xelu/xelu.zip");
    if !xelu_zip.exists() {
        status!("Downloading", "{}", url);
        run(format!("curl {} --output {}", url, xelu_zip.display()));
    }

    let readme_txt = Path::new("thindx/examples/assets/xelu/Readme.txt");
    if !readme_txt.exists() {
        status!("Extracting", "{}", url);
        run_in(xelu_dir, "tar -xf xelu.zip");
    }
}

struct ExampleOutput {
    pub src:        String,
    pub console:    String,
    pub screenshot: Option<Vec<u8>>,
}

impl ExampleOutput {
    pub fn get(example_name: &str, config: &str) -> Self {
        debug_assert!(!example_name.contains("\\"));
        debug_assert!(!example_name.contains("/"));
        debug_assert!(!example_name.ends_with(".rs"));
        let name = example_name;

        let src_path = format!(r"thindx/examples/{name}.rs", name=name);
        let exe_path = format!(r"target/{config}/examples/{name}.exe",       name=name, config=config);
        let con_path = format!(r"target/{config}/examples/{name}.out.txt",   name=name, config=config);
        let png_path = format!(r"target/{config}/examples/{name}.out.png",   name=name, config=config);

        let exe_modt = std::fs::metadata(&exe_path).ok().and_then(|m| m.modified().ok()).unwrap_or(SystemTime::UNIX_EPOCH);
        let con_modt = std::fs::metadata(&con_path).ok().and_then(|m| m.modified().ok()).unwrap_or(SystemTime::UNIX_EPOCH);
        let png_modt = std::fs::metadata(&png_path).ok().and_then(|m| m.modified().ok()).unwrap_or(SystemTime::UNIX_EPOCH);

        let src = std::fs::read_to_string(&src_path).unwrap_or_else(|err| fatal!(at: &src_path, "unable to read example source code: {}", err));

        let should_output_screenshot    = name.starts_with("d3d9-") || name.starts_with("d3d11-");
        let should_output_text          = name.starts_with("d3dcompiler-");
        let should_not_run              = name.starts_with("xinput-");
        if should_not_run {
            return ExampleOutput { src, console: String::new(), screenshot: None };
        }
        if !should_output_screenshot && !should_output_text {
            warning!("unknown prefix for example: {}", name);
            return ExampleOutput { src, console: String::new(), screenshot: None };
        }

        let should_run =
            (should_output_screenshot   && exe_modt > png_modt) ||
            (should_output_text         && exe_modt > con_modt);

        let console;
        if !should_run {
            status!("Skipping", "{} (console output and screenshots already up-to-date)", exe_path);
            if should_output_text {
                console = std::fs::read_to_string(&con_path).unwrap_or_else(|err| fatal!(at: &con_path, "unable to read cached console output: {}", err));
            } else {
                console = String::new();
            }
        } else {
            status!("Running", "{}", exe_path);
            let mut cmd = Command::new(&exe_path);
            cmd.env("THINDX_DOCS_EXAMPLE_SCREENSHOT_PATH", &png_path);
            if should_output_text {
                console = cmd.stdout0().unwrap_or_else(|err| fatal!("failed: {}", err));
            } else {
                cmd.status0().unwrap_or_else(|err| fatal!("failed: {}", err));
                console = String::new();
            }
            std::fs::write(&con_path, &console).unwrap_or_else(|err| warning!(at: &con_path, "unable to cache console output: {}", err));
        }

        let screenshot;
        if should_output_screenshot {
            screenshot = Some(std::fs::read(&png_path).unwrap_or_else(|err| fatal!(at: &png_path, "unable to read cached console output: {}", err)));
        } else {
            screenshot = None;
        }

        Self { src, console, screenshot }
    }
}
