use std::io::Write;

use mmrbi::*;



fn main() {
    let mut args = std::env::args();
    let _exe = args.next();

    let cmd = args.next().expect("command");
    match cmd.as_str() {
        "build"     => build(args),
        "check"     => check(args),
        other       => fatal!("unknown command {:?}", other),
    }
}

fn build(_args: std::env::Args) {
    // for some reason we need an abs path here, despite not requiring one when invoking `cargo doc` directly from the CLI
    let css = std::env::current_dir().unwrap().join("thindx/doc/style.css");
    std::env::set_var("RUSTDOCFLAGS", format!(r"--extend-css {css}", css = css.display()));

    run("cargo        fetch"                                );
    run("cargo        check --frozen --workspace --all-targets" );
    run("cargo        build --frozen --workspace --all-targets --exclude xtask");
    update_examples();
    run("cargo +nightly doc --frozen --workspace --no-deps" );
    run("cargo         test --frozen --workspace"           );
}

fn check(mut args: std::env::Args) {
    let orig_path = args.next().expect("path");
    let mut path = orig_path.split(|ch| "/\\".contains(ch)).collect::<Vec<_>>();

    let (package, mut path) = match path.get_mut(0..3) {
        Some(["thindx", "src", "headers"])  => ("thindx", &mut path[3..]),
        Some([package, "src", ..])          => (*package, &mut path[2..]),
        _other                              => fatal!("unable to check `{}`: not an expected package src folder", orig_path),
    };

    if let Some(last) = path.last_mut() {
        if !last.ends_with(".rs") {
            fatal!("unable to check `{}`: only rust-lang files supported", orig_path);
        }
        *last = &last[..last.len()-3];
        if last.starts_with("_") {
            let n = path.len();
            path = &mut path[..n-1]; // "foo\_foo.rs" => "foo"
        }
    }
    let pattern = path.join("::").replace(".", "_"); // "d3d11shader.h" => "d3d11shader_h"

    let mut cmd = Command::new("cargo");
    cmd.arg("test");
    cmd.arg("-p").arg(package);
    cmd.arg("--").arg(pattern);
    cmd.status0().unwrap_or_else(|err| fatal!("{}", err));
}



fn update_examples() {
    mmrbi::fs::write_if_modified_with("thindx/src/_examples.rs", |o|{
        writeln!(o, "// This file is autogenerated by _xtask.rs")?;
        writeln!(o)?;
        writeln!(o, "//! # Examples")?;
        writeln!(o, "use crate::*;")?;

        for e in mmrbi::fs::DirPathType::read_by_alphanumeric("thindx/examples").unwrap_or_else(|err| fatal!("unable to enumerate thindx/examples: {}", err)) {
            if !e.file_type.is_file() { continue }
            let name = e.path.file_name().unwrap_or_else(|| fatal!("expected file_name for {}", e.path.display()));
            let name = name.to_string_lossy();
            let name = match name.strip_suffix(".rs") { Some(n) => n, None => continue };

            let exe = format!("target/{config}/examples/{name}.exe", config="debug", name=name);
            status!("Running", "{}", exe);
            let out = Command::new(exe).current_dir("thindx").stdout0().unwrap_or_else(|err| fatal!("failed: {}", err));

            let src = std::fs::read_to_string(&e.path).unwrap_or_else(|err| fatal!("unable to read `{}`: {}", e.path.display(), err));
            let mut src = src.lines().peekable();

            writeln!(o)?;

            let mut any = false;
            while src.peek().map_or(false, |l| l.starts_with("//!")) {
                writeln!(o, "///{}", src.next().unwrap()[3..].trim_end())?;
                any = true;
            }
            if !any {
                writeln!(o, "/// {}", name)?;
            }
            writeln!(o, "///")?;
            writeln!(o, "/// <style>")?;
            writeln!(o, "/// #main {{ max-width: none; }}")?;
            writeln!(o, "/// </style>")?;

            while src.peek().map_or(false, |l| l.trim().is_empty()) { let _ = src.next(); }

            writeln!(o, "///")?;
            writeln!(o, "/// ### Source")?;
            writeln!(o, "/// ```no_run")?;
            for line in src {
                assert!(!line.contains("```"));
                writeln!(o, "/// {}", line.trim_end())?;
            }
            writeln!(o, "/// ```")?;
            if !out.is_empty() {
                writeln!(o, "///")?;
                writeln!(o, "/// ### Output")?;
                writeln!(o, "/// ```text")?;
                for line in out.lines() {
                    assert!(!line.contains("```"));
                    writeln!(o, "/// {}", line.trim_end())?;
                }
                writeln!(o, "/// ```")?;
            }
            writeln!(o, "///")?;
            writeln!(o, "/// ### To run this example yourself")?;
            writeln!(o, "/// ```cmd")?;
            writeln!(o, "/// git clone https://github.com/MaulingMonkey/thindx")?;
            writeln!(o, "/// cd thindx/thindx")?;
            writeln!(o, "/// cargo run --example {}", name)?;
            writeln!(o, "/// ```")?;
            writeln!(o, "pub const {} : () = ();", name.replace("-", "_"))?;
        }

        Ok(())
    }).unwrap_or_else(|err| fatal!("unable to create `thindx/src/_examples.rs`: {}", err));
}

fn run(command: &str) {
    let mut c = cmd(command);
    status!("Running", "{:?}", c);
    c.status0().unwrap_or_else(|err| fatal!("{}", err));
}

fn cmd(original: &str) -> Command {
    let mut args = Vec::new();

    let mut s = original.chars().peekable();
    'parse_next_arg: loop {
        while s.peek() == Some(&' ') { let _space = s.next(); } // ignore leading whitespace
        if s.peek().is_none() { break }

        let mut arg = String::new();
        if s.peek() == Some(&'\"') { // arg is quoted
            let _quote = s.next();
            while let Some(ch) = s.next() {
                if ch == '\\' && s.peek() == Some(&'\"') { // escaped interior quote
                    let _esc_quote = s.next();
                    arg.push('\"');
                } else if ch == '\"' { // ending quote
                    args.push(arg);
                    continue 'parse_next_arg;
                } else {
                    arg.push(ch);
                }
            }
            fatal!("unable to parse `{}`: last quoted arg was never terminated", original);
        } else { // arg is unquoted
            while let Some(ch) = s.next() {
                if ch == ' ' { // ending space
                    args.push(arg);
                    continue 'parse_next_arg;
                } else if ch == '\"' {
                    fatal!("unable to parse `{}`: unquoted arg has interior quotes", original);
                } else {
                    arg.push(ch);
                }
            }
            args.push(arg);
        }
    }

    match &args[..] {
        [ exe, args @ .. ] => {
            let mut cmd = Command::new(exe);
            cmd.args(args);
            cmd
        },
        [] => fatal!("unable to parse `{}`: empty/blank string? no args were parsed", original),
    }
}
